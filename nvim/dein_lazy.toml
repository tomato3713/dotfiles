[[plugins]]
repo = 'Shougo/ddc.vim'
on_event = ['BufEnter']
hook_source = '''
  call pum#set_option({
    \ 'max_width': 100,
    \ 'padding': v:true,
    \ })

  call ddc#custom#patch_global('completionMenu', 'pum.vim')
  call ddc#custom#patch_global('sources', ['skkeleton', 'nvim-lsp', 'around', 'file'])
  call ddc#custom#patch_global('sourceOptions',
    \ {
    \   '_': {
    \     'matchers': ['matcher_fuzzy'],
    \     'sorters': ['sorter_fuzzy'],
    \     'converters': ['converter_fuzzy']
    \   },
    \   'around': {
    \     'mark': 'around',
    \   },
    \   'nvim-lsp': {
    \     'mark': 'lsp',
    \     'forceCompletionPattern': '\.\w*|:\w*|->\w*',
    \   },
    \   'skkeleton': {
    \     'mark': 'skk',
    \     'matchers': ['skkeleton'],
    \     'sorters': [],
    \     'minAutoCompleteLength': 1,
    \     'isVolatile': v:true,
    \   },
    \   'file': {
    \     'mark': 'file',
    \     'forceCompletionPattern': '\S/\S*',
    \     'isVolatile': v:true,
    \   },
    \ })

  call ddc#custom#patch_global('autoCompleteEvents',
      \ ['InsertEnter', 'TextChangedI', 'TextChangedP', 'CmdlineChanged'])
  nnoremap :       <Cmd>call CommandlinePre()<CR>:

  function! CommandlinePre() abort
    cnoremap <Tab>   <Cmd>call pum#map#insert_relative(+1)<CR>
    cnoremap <S-Tab> <Cmd>call pum#map#insert_relative(-1)<CR>
    cnoremap <C-n>   <Cmd>call pum#map#insert_relative(+1)<CR>
    cnoremap <C-p>   <Cmd>call pum#map#insert_relative(-1)<CR>
    cnoremap <C-y>   <Cmd>call pum#map#confirm()<CR>
    cnoremap <C-e>   <Cmd>call pum#map#cancel()<CR>

    " Overwrite sources
    if !exists('b:prev_buffer_config')
      let b:prev_buffer_config = ddc#custom#get_buffer()
    endif
    call ddc#custom#patch_buffer('cmdlineSources', ['cmdline', 'cmdline-history', 'skkeleton', 'around', 'file'])
    call ddc#custom#patch_buffer('sourceOptions',
      \ {
      \   '_': {
      \     'matchers': ['matcher_fuzzy'],
      \     'sorters': ['sorter_fuzzy'],
      \     'converters': ['converter_fuzzy']
      \   },
      \   'cmdline': {
      \     'mark': 'cmd',
      \   },
      \   'cmdline-history': {
      \     'mark': 'cmd hist',
      \   },
      \ })

    autocmd User DDCCmdlineLeave ++once call CommandlinePost()
    autocmd InsertEnter <buffer> ++once call CommandlinePost()

    " Enable command line completion
    call ddc#enable_cmdline_completion()
  endfunction
  function! CommandlinePost() abort
    silent! cunmap <Tab>
    silent! cunmap <S-Tab>
    silent! cunmap <C-n>
    silent! cunmap <C-p>
    silent! cunmap <C-y>
    silent! cunmap <C-e>

    " Restore sources
    if exists('b:prev_buffer_config')
      call ddc#custom#set_buffer(b:prev_buffer_config)
      unlet b:prev_buffer_config
    else
      call ddc#custom#set_buffer({})
    endif
  endfunction

  call ddc#enable()
'''

[[plugins]]
repo = 'Shougo/pum.vim'
on_source = 'ddc.vim'
hook_source = '''
'''

[[plugins]]
repo = 'matsui54/denops-signature_help'
depends = ['denops.vim']
on_source = 'ddc.vim'
hook_source = '''
call signature_help#enable()
'''

[[plugins]]
repo = 'matsui54/denops-popup-preview.vim'
depends = ['denops.vim']
on_source = 'ddc.vim'
hook_source = '''
call popup_preview#enable()
'''

# start ddc sources
[[plugins]]
repo = 'Shougo/ddc-around'
on_source = 'ddc.vim'

[[plugins]]
repo = 'LumaKernel/ddc-file'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-nvim-lsp'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-cmdline-history'
on_source = 'ddc.vim'

[[plugins]]
repo = 'Shougo/ddc-cmdline'
on_source = 'ddc.vim'

[[plugins]]
repo = 'vim-skk/skkeleton'
depends = ['denops.vim']
on_source = 'ddc.vim'
hook_add = '''
let s:skk_dir = expand('~/.config/skk')
let s:global_skk_jisyo = s:skk_dir . '/SKK-JISYO.L'
let s:user_skk_jisyo = s:skk_dir . '/user-dict'
let s:skk_dict_url = 'http://openlab.jp/skk/skk/dic/SKK-JISYO.L'

imap <C-j> <Plug>(skkeleton-toggle)
cmap <C-j> <Plug>(skkeleton-toggle)

" download skk dictionary file
if !isdirectory(s:skk_dir)
    call mkdir(s:skk_dir)
    execute '!curl' s:skk_dict_url '-o' expand(s:global_skk_jisyo)
endif

function! s:skkeleton_init() abort
  call skkeleton#config({
    \ 'eggLikeNewline': v:true,
    \ 'keepState': v:false,
    \ 'globalJisyo': s:global_skk_jisyo,
    \ 'userJisyo': s:user_skk_jisyo,
    \ 'immediatelyJisyoRW': v:false,
    \ 'markerHenkan': '|',
    \ 'markerHenkanSelect': '?'
    \ })
  call skkeleton#register_kanatable('rom', {
    \ "z\<Space>": ["\u3000", ''],
    \ "z.": ["．", ''],
    \ "z,": ["，", '']
    \ })
endfunction
augroup skkeleton-initialize-pre
  autocmd!
  autocmd User skkeleton-initialize-pre call s:skkeleton_init()
augroup END
'''

[[plugins]]
repo = 'delphinus/skkeleton_indicator.nvim'
on_source = 'skkeleton'
hook_source = '''
lua << EOF
require('skkeleton_indicator').setup{}
EOF
'''
# end ddc sources

# start ddc filters
[[plugins]]
repo = 'tani/ddc-fuzzy'
on_source = 'ddc.vim'
# start ddc filters

# start LSP
[[plugins]]
repo = 'neovim/nvim-lspconfig'
on_event = 'BufEnter'
hook_source= '''
lua << EOF
local nvim_lsp = require('lspconfig')
local on_attach = function(client,bufnr)
local function buf_set_keymap(...) vim.api.nvim_buf_set_keymap(bufnr, ...) end
local function buf_set_option(...) vim.api.nvim_buf_set_option(bufnr, ...) end

local opts = { noremap=true, silent=true }
  buf_set_keymap('n', 'gd', '<Cmd>lua vim.lsp.buf.definition()<CR>', opts)
  buf_set_keymap('n', 'K', '<Cmd>lua vim.lsp.buf.hover()<CR>', opts)
  buf_set_keymap('n', 'gi', '<Cmd>lua vim.lsp.buf.implementation()<CR>', opts)
  buf_set_keymap('n', 'gs', '<Cmd>lua vim.lsp.buf.signature_help()<CR>', opts)
  buf_set_keymap('n', 'gr', '<Cmd>lua vim.lsp.buf.references()<CR>', opts)
  buf_set_keymap('n', 'gx', '<Cmd>lua vim.lsp.buf.diagnostic.show_line_diagnostics()<CR>', opts)
  buf_set_keymap('n', 'g[', '<Cmd>lua vim.lsp.buf.diagnostic.show_prev()<CR>', opts)
  buf_set_keymap('n', 'g]', '<Cmd>lua vim.lsp.buf.diagnostic.show_next()<CR>', opts)
end

local lsp_installer = require("nvim-lsp-installer")
lsp_installer.on_server_ready(function(server)
  local opts = {}
  opts.on_attach = on_attach
  server:setup(opts)
  vim.cmd [[do User LspAttachBuffers]]
end)
EOF
'''

[[plugins]]
repo = 'williamboman/nvim-lsp-installer'
on_source = 'nvim-lspconfig'
# end LSP

[[plugins]]
repo = 'nvim-treesitter/nvim-treesitter'
merged = 0
hook_post_update = 'TSUpdate'
hook_source = '''
require'nvim-treesitter.configs'.setup {
  ensure_installed = { "go", "c", "cpp", "markdown", "toml" },
  sync_install = false, -- install languages synchronously (only applied to `ensure_installed`)
  highlight = {
    enable = true,              -- false will disable the whole extension
    disable = { "vim" },  -- list of language that will be disabled
    additional_vim_regex_highlighting = false,
  },
  indent = {
      enable = true,
  }
}
'''

[[plugins]]
repo = 'skanehira/translate.vim'
hook_add = '''
let g:translate_target = 'ja'
let g:translate_popup_window = 0
let g:translate_winsize = 5
vmap t <Plug>(VTranslate)
'''

